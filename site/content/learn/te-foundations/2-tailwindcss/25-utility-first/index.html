---
title: Utility-first in CSS - Tailwind CSS tutorial"
url: "/learn/te-foundations/tailwind-css/utility-first/"
accordion_section: "headingTailwindCSS"
date: 2023-04-20T16:00:58+02:00
draft: false

seo_title: "Learn the fundamentals of the utility-first - the approach that revolutionized CSS in recent years and made Tailwind CSS extremely popular"
description: ""
image: "https://tw-elements.com/learn/te-foundations/basics/introduction/assets/tailwind-elements.png"
video: ""
layout: tutorial
hidden_sidenav: true
previous_lesson: "/learn/te-foundations/tailwind-css/hsla-colors/"
next_lesson: "/learn/te-foundations/tailwind-css/buttons/"
---

<!-- Section: Text -->
<section class="">
  <h1 class="mb-2 mt-0 text-3xl font-semibold leading-tight">
    Utility-first approach
  </h1>

  <hr
    class="my-7 h-0.5 border-t-0 bg-neutral-100 opacity-100 dark:opacity-50" />

  <p class="mb-3">
    Utility-first is an approach that revolutionized CSS in recent years and
    made Tailwind CSS extremely popular. But what is it exactly about and why
    does it matter?
  </p>

  <p class="mb-3">
    In this lesson, we'll use a (seemingly) simple
    <strong>button</strong> component to explain the concept of the
    utility-first approach.
  </p>

  <!-- TE divider -->
  <hr
    class="my-7 h-0.5 border-t-0 bg-neutral-100 opacity-100 dark:opacity-50" />

  <p class="mb-3">Although small, the buttons can cause trouble.</p>

  <p class="mb-3">
    Compared to, for example, Bootstrap, where buttons consist of only 2 classes
    (e.g. <code>.btn</code> and <code>.btn-primary</code>), buttons built in
    Tailwind appear to be more tricky.
  </p>

  <p class="mb-3">Why?</p>

  <p class="mb-3">
    Because in Bootstrap classes like <code>.btn</code> or
    <code>.btn-primary</code> are responsible for a lot of things - padding,
    margins, color, hover state, active state and many more.
  </p>

  <!-- TE code html -->
  <div class="mb-8">
    {{< twsnippet/wrapper "HTML" "" "mobile" >}}{{< twsnippet/code active=true lang="HTML" >}}
    <!-- Typical Bootstrap button -->
    <button class="btn btn-primary">Button</button>

    {{< /twsnippet/code >}}{{< /twsnippet/wrapper >}}
  </div>

  <!-- TE tutorial step-->
  <h2 class="mb-6 mt-12 text-xl font-semibold">Abstraction layer</h2>

  <p class="mb-3">
    In such a situation, when we are unable to guess from the name itself what
    exactly a given class (such as <code>.btn</code>) does, we say that it
    imposes a layer of abstraction.
  </p>

  <p class="mb-3">
    Of course, we can guess quite easily that the <code>.btn</code> class
    creates a button, but we can't guess from the name itself what exactly the
    padding, margins, color, etc. are. And although we can guess that the
    <code>.btn-primary</code> class creates primary buttons, we don't know what
    "primary" actually means.
  </p>

  <p class="mb-3">So these classes are abstract.</p>

  <p class="mb-3">
    In simple terms - if we are unable to guess from the name of the class
    itself the specific CSS properties that this class applies, we say that it
    is abstract or that it imposes a layer of abstraction.
  </p>

  <!-- TE tutorial step-->
  <h2 class="mb-6 mt-12 text-xl font-semibold">
    What does the utility-first approach propose instead?
  </h2>

  <p class="mb-8">
    Utility-first is a CSS methodology where you build up your styles using many
    small, purpose-specific classes.
  </p>

  <p class="mb-4 text-lg font-bold">Traditional CSS</p>

  <p class="mb-3">
    To illustrate it let's take an example of a button styled using traditional
    CSS.
  </p>

  <p class="mb-3">
    First, we need to create a class <code>.btn</code> and apply to it desired
    CSS properties:
  </p>

  <!-- TE code html -->
  <div class="mb-8">
    {{< twsnippet/wrapper "CSS" "" "mobile" >}}{{< twsnippet/code active=true lang="CSS" >}}

    .btn { padding: 0.5em 1em; background-color: blue; color: white;
    border-radius: 0.25em; }
    {{< /twsnippet/code >}}{{< /twsnippet/wrapper >}}
  </div>

  <p class="mb-3">Then we can use this class in our HTML:</p>

  <!-- TE code html -->
  <div class="mb-12">
    {{< twsnippet/wrapper "HTML" "" "mobile" >}}{{< twsnippet/code active=true lang="HTML" >}}


    <button class="btn">Click me</button>

    {{< /twsnippet/code >}}{{< /twsnippet/wrapper >}}
  </div>

  <p class="mb-3">And this will be the result:</p>

  <!-- TE demo box -->
  <div class="mb-8 flex justify-center rounded-lg border bg-gray-100 p-8">
    <button class="rounded-md bg-blue-500 px-4 py-2 text-white">
      Click me
    </button>
  </div>

  <p class="mb-4 text-lg font-bold">Tailwind CSS</p>

  <p class="mb-3">
    The same button using a utility-first approach in Tailwind would look like
    this:
  </p>

  <!-- TE code html -->
  <div class="mb-8">
    {{< twsnippet/wrapper "HTML" "" "mobile" >}}{{< twsnippet/code active=true lang="HTML" >}}


    <button class="rounded-md bg-blue-500 px-4 py-2 text-white">
      Click me
    </button>

    {{< /twsnippet/code >}}{{< /twsnippet/wrapper >}}
  </div>

  <p class="mb-3">
    What catches the eye at first glance is that the Tailwind button is much
    more verbose.
  </p>

  <p class="mb-3">
    In traditional CSS we have only one class, and in Tailwind as many as 5.
  </p>

  <p class="mb-6">
    And this is just the beginning - to apply the styles for hover state, active
    state, disable state to our button, we will need a lot of classes.
  </p>

  <p class="mb-4 font-bold">But what do you get in return?</p>

  <!-- TE list arrows -->
  <ul class="mb-10">
    <li class="mb-4">
      <svg
        xmlns="http://www.w3.org/2000/svg"
        viewBox="0 0 24 24"
        fill="currentColor"
        class="mr-1 inline h-5 w-5 fill-primary-700">
        <path
          fill-rule="evenodd"
          d="M16.72 7.72a.75.75 0 011.06 0l3.75 3.75a.75.75 0 010 1.06l-3.75 3.75a.75.75 0 11-1.06-1.06l2.47-2.47H3a.75.75 0 010-1.5h16.19l-2.47-2.47a.75.75 0 010-1.06z"
          clip-rule="evenodd"></path>
      </svg>
      <span
        ><strong class="font-semibold">Composability:</strong> You can compose
        complex designs by applying many utility classes. This allows you to
        avoid creating unique classes for every variation of a component.</span
      >
    </li>

    <li class="mb-4">
      <svg
        xmlns="http://www.w3.org/2000/svg"
        viewBox="0 0 24 24"
        fill="currentColor"
        class="mr-1 inline h-5 w-5 fill-primary-700">
        <path
          fill-rule="evenodd"
          d="M16.72 7.72a.75.75 0 011.06 0l3.75 3.75a.75.75 0 010 1.06l-3.75 3.75a.75.75 0 11-1.06-1.06l2.47-2.47H3a.75.75 0 010-1.5h16.19l-2.47-2.47a.75.75 0 010-1.06z"
          clip-rule="evenodd"></path>
      </svg>
      <span
        ><strong class="font-semibold">Direct mapping:</strong> The styling of
        an element is clear just by looking at the HTML. There's no need to jump
        to a separate CSS file to understand the styles applied.</span
      >
    </li>

    <li class="mb-4">
      <svg
        xmlns="http://www.w3.org/2000/svg"
        viewBox="0 0 24 24"
        fill="currentColor"
        class="mr-1 inline h-5 w-5 fill-primary-700">
        <path
          fill-rule="evenodd"
          d="M16.72 7.72a.75.75 0 011.06 0l3.75 3.75a.75.75 0 010 1.06l-3.75 3.75a.75.75 0 11-1.06-1.06l2.47-2.47H3a.75.75 0 010-1.5h16.19l-2.47-2.47a.75.75 0 010-1.06z"
          clip-rule="evenodd"></path>
      </svg>
      <span
        ><strong class="font-semibold">Customizability:</strong> You can
        generate a wide array of utility classes from your configuration file in
        Tailwind, allowing for project-specific customization.</span
      >
    </li>

    <li class="mb-4">
      <svg
        xmlns="http://www.w3.org/2000/svg"
        viewBox="0 0 24 24"
        fill="currentColor"
        class="mr-1 inline h-5 w-5 fill-primary-700">
        <path
          fill-rule="evenodd"
          d="M16.72 7.72a.75.75 0 011.06 0l3.75 3.75a.75.75 0 010 1.06l-3.75 3.75a.75.75 0 11-1.06-1.06l2.47-2.47H3a.75.75 0 010-1.5h16.19l-2.47-2.47a.75.75 0 010-1.06z"
          clip-rule="evenodd"></path>
      </svg>
      <span
        ><strong class="font-semibold">Responsive design:</strong> Tailwind
        provides utility classes for handling responsive designs out of the box.
        You can control the styles for different screen sizes using these
        utility classes.</span
      >
    </li>

    <li class="mb-4">
      <svg
        xmlns="http://www.w3.org/2000/svg"
        viewBox="0 0 24 24"
        fill="currentColor"
        class="mr-1 inline h-5 w-5 fill-primary-700">
        <path
          fill-rule="evenodd"
          d="M16.72 7.72a.75.75 0 011.06 0l3.75 3.75a.75.75 0 010 1.06l-3.75 3.75a.75.75 0 11-1.06-1.06l2.47-2.47H3a.75.75 0 010-1.5h16.19l-2.47-2.47a.75.75 0 010-1.06z"
          clip-rule="evenodd"></path>
      </svg>
      <span
        ><strong class="font-semibold">Efficiency:</strong> You avoid bloating
        your CSS with unnecessary or unused styles. This approach promotes the
        creation of styles as they are needed, which can lead to more efficient
        CSS.</span
      >
    </li>

    <li class="mb-4">
      <svg
        xmlns="http://www.w3.org/2000/svg"
        viewBox="0 0 24 24"
        fill="currentColor"
        class="mr-1 inline h-5 w-5 fill-primary-700">
        <path
          fill-rule="evenodd"
          d="M16.72 7.72a.75.75 0 011.06 0l3.75 3.75a.75.75 0 010 1.06l-3.75 3.75a.75.75 0 11-1.06-1.06l2.47-2.47H3a.75.75 0 010-1.5h16.19l-2.47-2.47a.75.75 0 010-1.06z"
          clip-rule="evenodd"></path>
      </svg>
      <span
        ><strong class="font-semibold">Consistency:</strong> This approach
        encourages consistency across a project, as it naturally creates a
        limited set of styles to use.</span
      >
    </li>
  </ul>

  <!-- TE divider -->
  <hr
    class="my-7 h-0.5 border-t-0 bg-neutral-100 opacity-100 dark:opacity-50" />

  <p class="mb-3">
    While utility-first approach might look verbose at first, it actually
    promotes consistency, customization, and efficiency in your styles. Also,
    once you get used to this approach, it can significantly speed up your
    development process.
  </p>
</section>
<!-- Section: Text -->
